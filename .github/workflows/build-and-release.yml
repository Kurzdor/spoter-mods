name: Build and Release

on:
  push:
    branches:
      - master  # ветка, на которую пушить изменения

jobs:
  build:
    runs-on: windows-latest  # Используем Windows для сборки

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
      with:
        fetch-depth: 0  # Получаем всю историю коммитов

    - name: Install Python 2.7 manually
      run: |
        # Скачиваем Python 2.7
        $pythonUrl = "https://www.python.org/ftp/python/2.7.18/python-2.7.18.amd64.msi"
        $pythonInstaller = "$env:RUNNER_TEMP\python-2.7.18.amd64.msi"
        Invoke-WebRequest -Uri $pythonUrl -OutFile $pythonInstaller

        # Устанавливаем Python 2.7
        Start-Process msiexec.exe -ArgumentList "/i $pythonInstaller /quiet" -Wait

        # Добавляем Python в PATH с использованием Environment Files
        $pythonPath = "C:\Python27"
        $pythonScriptsPath = "$pythonPath\Scripts"
        echo "$pythonPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        echo "$pythonScriptsPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Verify Python installation
      run: |
        python --version
        pip --version

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r .github/workflows/requirements.txt  # Указываем путь к requirements.txt

    - name: Check commit message for release keywords
      id: check_commit
      run: |
        # Получаем сообщение последнего коммита
        $commitMessage = git log -1 --pretty=%B

        # Экранируем кавычки в сообщении коммита
        $commitMessage = $commitMessage -replace '"', '`"'

        # Проверяем, содержит ли сообщение ключевые слова
        $releasePattern = "(?i)release|релиз"  # Регулярное выражение для release/релиз (регистронезависимо)
        $allPattern = "(?i)all|всех|все|всё"  # Регулярное выражение для all/всех/все/всё (регистронезависимо)

        $isRelease = $commitMessage -match $releasePattern
        $isAll = $commitMessage -match $allPattern

        if ($isRelease) {
          echo "Commit message contains release keyword."
          echo "is_release=true" >> $env:GITHUB_OUTPUT
          echo "commit_message=$commitMessage" >> $env:GITHUB_OUTPUT
          echo "is_all=$isAll" >> $env:GITHUB_OUTPUT
        } else {
          echo "Commit message does not contain release keyword. Skipping build."
          echo "is_release=false" >> $env:GITHUB_OUTPUT
        }

    - name: Determine modified mods
      id: modified_mods
      if: steps.check_commit.outputs.is_release == 'true' || contains(github.event.head_commit.modified, '.github/game_version.json')
      run: |
        # Получаем список модов из game_version.json
        $modList = Get-Content -Path .github/game_version.json -Raw | ConvertFrom-Json | Select-Object -ExpandProperty mod_list
    
        # Если в сообщении коммита есть all/всех/все/всё, собираем все моды
        if ('${{ steps.check_commit.outputs.is_all }}' -eq 'true') {
          echo "Building all mods because 'release all' keyword was found."
          echo "updated_mods=$($modList -join ',')" >> $env:GITHUB_OUTPUT
        } else {
          # Иначе ищем измененные моды только в source
          $modifiedFiles = git diff --name-only ${{ github.event.before }} ${{ github.sha }}
          $updatedMods = @()
          foreach ($mod in $modList) {
            if ($modifiedFiles -match "$mod/source/") {
              echo "Modified mod: $mod"
              $updatedMods += $mod
            }
          }
    
          # Сохраняем список обновленных модов
          if ($updatedMods.Count -gt 0) {
            echo "Updated mods: $($updatedMods -join ',')"
            echo "updated_mods=$($updatedMods -join ',')" >> $env:GITHUB_OUTPUT
          } else {
            echo "No mods were updated."
            echo "updated_mods=" >> $env:GITHUB_OUTPUT
          }
        }

    - name: Debug updated_mods
      run: |
        echo "Updated mods: ${{ steps.modified_mods.outputs.updated_mods }}"

    - name: Read game versions and mod versions
      id: versions
      if: steps.modified_mods.outputs.updated_mods != ''
      run: |
        # Чтение данных из JSON-файла
        $data = Get-Content -Path .github/game_version.json -Raw | ConvertFrom-Json
        $wg_version = $data.CLIENT_VERSION_WG
        $lesta_version = $data.CLIENT_VERSION_RU

        # Получаем список обновленных модов
        $updatedMods = "${{ steps.modified_mods.outputs.updated_mods }}" -split ","

        # Чтение версий модов
        $modVersions = @{}
        foreach ($mod in $updatedMods) {
          $modVersion = Get-Content -Path "$mod/source/VERSION" -Raw | ConvertFrom-Json | Select-Object -ExpandProperty version
          $modVersions[$mod] = $modVersion
        }

        # Получаем текущую дату
        $currentDate = Get-Date -Format "yyyy-MM-dd"

        # Определяем mark (World of Tanks или Tanki Lesta)
        $mark = if ($wg_version) { "World of Tanks" } else { "Tanki Lesta" }

        # Сохраняем данные в outputs для использования в следующих шагах
        echo "wg_version=$wg_version" >> $env:GITHUB_OUTPUT
        echo "lesta_version=$lesta_version" >> $env:GITHUB_OUTPUT
        echo "updated_mods=$($updatedMods -join ',')" >> $env:GITHUB_OUTPUT
        echo "mod_versions=$($modVersions | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
        echo "date=$currentDate" >> $env:GITHUB_OUTPUT
        echo "mark=$mark" >> $env:GITHUB_OUTPUT
        echo "client=${{ steps.versions.outputs.wg_version || steps.versions.outputs.lesta_version }}" >> $env:GITHUB_OUTPUT

    - name: Run build script
      if: steps.modified_mods.outputs.updated_mods != ''
      run: |
        python .github/createRelease.py ${{ steps.versions.outputs.lesta_version }} ${{ steps.versions.outputs.wg_version }} "${{ steps.modified_mods.outputs.updated_mods }}"

    - name: Create Release
      id: create_release
      if: steps.modified_mods.outputs.updated_mods != ''
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release v${{ github.run_number }}
        body: |
          ${{ toJson(fromJson(steps.versions.outputs.mod_versions)) }}
        draft: false
        prerelease: false

    - name: Upload WG Mod Archives
      if: steps.modified_mods.outputs.updated_mods != ''
      run: |
        $updatedMods = "${{ steps.versions.outputs.updated_mods }}" -split ","
        foreach ($mod in $updatedMods) {
          $archivePath = "$mod/zip/$mod.zip"
          if (Test-Path $archivePath) {
            echo "Uploading $archivePath"
            gh release upload v${{ github.run_number }} $archivePath --clobber
          } else {
            echo "Archive not found: $archivePath"
          }
        }
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload Lesta Mod Archives
      if: steps.modified_mods.outputs.updated_mods != ''
      run: |
        $updatedMods = "${{ steps.versions.outputs.updated_mods }}" -split ","
        foreach ($mod in $updatedMods) {
          $archivePath = "$mod/zip/${mod}_RU.zip"
          if (Test-Path $archivePath) {
            echo "Uploading $archivePath"
            gh release upload v${{ github.run_number }} $archivePath --clobber
          } else {
            echo "Archive not found: $archivePath"
          }
        }
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update README files
      if: steps.modified_mods.outputs.updated_mods != ''
      run: |
        $updatedMods = "${{ steps.versions.outputs.updated_mods }}" -split ","
        foreach ($mod in $updatedMods) {
          $wgArchiveUrl = "https://github.com/spoter/spoter-mods/releases/download/v${{ github.run_number }}/$mod.zip"
          $lestaArchiveUrl = "https://github.com/spoter/spoter-mods/releases/download/v${{ github.run_number }}/${mod}_RU.zip"

          # Получаем версию мода
          $modVersion = (Get-Content -Path "$mod/source/VERSION" -Raw | ConvertFrom-Json).version

          # Обновляем или создаем файл имя_мода/zip/README.md
          $zipReadmePath = "$mod/zip/README.md"
          $zipReadmeContent = "# $mod\n\n#### Скачать [$mod]: #$modVersion (${{ steps.versions.outputs.date }}) #World of Tanks ${{ steps.versions.outputs.wg_version }}]($wgArchiveUrl)\n\n#### Скачать [$mod]: #$modVersion (${{ steps.versions.outputs.date }}) #Tanki Lesta ${{ steps.versions.outputs.lesta_version }}]($lestaArchiveUrl)"
          Set-Content -Path $zipReadmePath -Value $zipReadmeContent

          # Обновляем или создаем файл имя_мода/README.md
          $modReadmePath = "$mod/README.md"
          $modReadmeContent = "# $mod\n\n#### Скачать [$mod]: #$modVersion (${{ steps.versions.outputs.date }}) #World of Tanks ${{ steps.versions.outputs.wg_version }}]($wgArchiveUrl)\n\n#### Скачать [$mod]: #$modVersion (${{ steps.versions.outputs.date }}) #Tanki Lesta ${{ steps.versions.outputs.lesta_version }}]($lestaArchiveUrl)"
          Set-Content -Path $modReadmePath -Value $modReadmeContent
        }

    - name: Commit and push changes
      if: steps.modified_mods.outputs.updated_mods != ''
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git add .
        git commit -m "#update resources for ${{ steps.check_commit.outputs.commit_message }}"
        git push